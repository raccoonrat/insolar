//
// Copyright 2019 Insolar Technologies GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package main

import (
	"github.com/gogo/protobuf/protoc-gen-gogo/generator"
	"github.com/gogo/protobuf/vanity"
	"github.com/gogo/protobuf/vanity/command"
)

const (
	BaseRecordName = "Record"
	BaseOneOfName  = "union"
)

// Generator is the type whose methods generate the output, stored in the associated response structure.
type RecordPluginGenerator struct {
	*generator.Generator
	generator.PluginImports
}

// Name identifies the plugin.
func (p *RecordPluginGenerator) Name() string {
	return "RecordPlugin"
}

// Init is called once after data structures are built but before
// code generation begins.
func (p *RecordPluginGenerator) Init(g *generator.Generator) {
	p.Generator = g
	// p.GoPackageName("github.com/pkg/errors")

}

// Generate produces the code generated by the plugin for this file,
// except for the imports, by calling the generator's methods P, In, and Out.
func (p *RecordPluginGenerator) Generate(file *generator.FileDescriptor) {
	p.PluginImports = generator.NewPluginImports(p.Generator)

	msg := file.GetMessage(BaseRecordName)
	if msg == nil {
		return
	}

	oneOfList := msg.GetOneofDecl()
	if len(oneOfList) != 1 {
		return
	} else if oneOfList[0].Name == nil || *oneOfList[0].Name != BaseOneOfName {
		return
	}

	errorsPkg := p.NewImport("github.com/pkg/errors")

	// Unmarshal function
	p.P(`// Returns pointer to any sub-record type or error`)
	p.P(`func UnmarshalRecord(data []byte) (interface{}, error) {`)
	p.P(`  base := `, BaseRecordName, `{}`)
	p.P()
	p.P(`  if error := base.Unmarshal(data); error != nil {`)
	p.P(`    return nil, `, errorsPkg.Use(), `.Wrap(error, "Failed to unmarshal request")`)
	p.P(`  }`)
	p.P()
	p.P(`  union := base.GetUnion()`)
	p.P()
	p.P(`  if union == nil {`)
	p.P(`    return nil, `, errorsPkg.Use(), `.New("We go empty request")`)
	p.P(`  }`)
	p.P()
	p.P(`  var subRecord interface{}`)
	p.P()
	p.P(`  switch union.(type) {`)
	for _, field := range msg.GetField() {
		// p.P(`  case *`, BaseRecordName, `_`, field.GetName(), `:`)
		// p.P(`    tp := union.(*`, BaseRecordName, `_`, field.GetName(), `)`)
		// p.P(`    t := *tp`)
		// p.P(`    return t.`, field.GetName())
		p.P(`  case *`, BaseRecordName, `_`, field.GetName(), `:`)
		p.P(`    subRecord = *union.(*`, BaseRecordName, `_`, field.GetName(), `).`, field.GetName())
	}
	p.P(`  default:`)
	p.P(`    return nil, fmt.Errorf("`, BaseRecordName, `.`, BaseOneOfName, ` has unexpected type %T", subRecord)`)
	p.P(`  }`)
	p.P(`  return subRecord, nil`)
	p.P(`}`)

	p.P()

	// Marshal function
	p.P(`// Puts sub-record into record and convert it to binary (if any)`)
	p.P(`func MarshalRecord(subRecord interface{}) ([]byte, error) {`)
	p.P(`  base := `, BaseRecordName, `{}`)
	p.P()
	p.P(`  switch subRecord.(type) {`)
	for _, field := range msg.GetField() {
		p.P(`  case *`, field.GetName(), BaseRecordName, `:`)
		p.P(`    base.Union = &`, BaseRecordName, `_`, field.GetName(), `{ `)
		p.P(`      subRecord.(*`, field.GetName(), BaseRecordName, `),`)
		p.P(`    }`)
	}
	p.P(`  default:`)
	p.P(`    return nil, fmt.Errorf("`, BaseRecordName, `.`, BaseOneOfName, ` has unexpected type %T", subRecord)`)
	p.P(`  }`)
	p.P(`  return base.Marshal()`)
	p.P(`}`)

}

// GenerateImports produces the import declarations for this file.
// It is called after Generate.
func (p RecordPluginGenerator) GenerateImport(file *generator.FileDescriptor) {
	println("generaint import")
	// if len(file.FileDescriptorProto.Service) == 0 {
	// 	return
	// }
	// p.AddImport("github.com/pkg/errors")
	p.PrintImport("errors", "github.com/pkg/errors")
	// p.PrintImport("log", "log")
	// p.P()
}

func main() {
	req := command.Read()
	files := req.GetProtoFile()
	files = vanity.FilterFiles(files, vanity.NotGoogleProtobufDescriptorProto)

	vanity.ForEachFile(files, vanity.TurnOnMarshalerAll)
	vanity.ForEachFile(files, vanity.TurnOnSizerAll)
	vanity.ForEachFile(files, vanity.TurnOnUnmarshalerAll)

	vanity.ForEachFieldInFilesExcludingExtensions(vanity.OnlyProto2(files), vanity.TurnOffNullableForNativeTypesWithoutDefaultsOnly)
	vanity.ForEachFile(files, vanity.TurnOffGoUnrecognizedAll)
	vanity.ForEachFile(files, vanity.TurnOffGoUnkeyedAll)
	vanity.ForEachFile(files, vanity.TurnOffGoSizecacheAll)

	vanity.ForEachFile(files, vanity.TurnOffGoEnumPrefixAll)
	vanity.ForEachFile(files, vanity.TurnOffGoEnumStringerAll)
	vanity.ForEachFile(files, vanity.TurnOnEnumStringerAll)

	vanity.ForEachFile(files, vanity.TurnOnEqualAll)
	vanity.ForEachFile(files, vanity.TurnOnGoStringAll)
	vanity.ForEachFile(files, vanity.TurnOffGoStringerAll)
	vanity.ForEachFile(files, vanity.TurnOnStringerAll)

	// our own flags:
	vanity.ForEachFile(files, vanity.TurnOffGoGettersAll)

	resp := command.Generate(req)
	command.Write(resp)

	gen := RecordPluginGenerator{}

	// gen.ImportMap["errors"] = "github.com/pkg/errors"
	resp = command.GeneratePlugin(req, &gen, ".pb_ext.go")
	command.Write(resp)
}

func init() {
	generator.RegisterPlugin(&RecordPluginGenerator{})
}
