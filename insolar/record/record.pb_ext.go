// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: insolar/record/record.proto

package record

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_pkg_errors "github.com/pkg/errors"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Returns pointer to any sub-record type or error
func UnmarshalRecord(data []byte) (interface{}, error) {
	base := Record{}

	if error := base.Unmarshal(data); error != nil {
		return nil, github_com_pkg_errors.Wrap(error, "Failed to unmarshal request")
	}

	union := base.GetUnion()

	if union == nil {
		return nil, github_com_pkg_errors.New("We go empty request")
	}

	var subRecord interface{}

	switch union.(type) {
	case *Record_Genesis:
		subRecord = *union.(*Record_Genesis).Genesis
	case *Record_Child:
		subRecord = *union.(*Record_Child).Child
	case *Record_Jet:
		subRecord = *union.(*Record_Jet).Jet
	case *Record_Request:
		subRecord = *union.(*Record_Request).Request
	case *Record_Result:
		subRecord = *union.(*Record_Result).Result
	case *Record_Type:
		subRecord = *union.(*Record_Type).Type
	case *Record_Code:
		subRecord = *union.(*Record_Code).Code
	case *Record_ObjectActivate:
		subRecord = *union.(*Record_ObjectActivate).ObjectActivate
	case *Record_ObjectAmend:
		subRecord = *union.(*Record_ObjectAmend).ObjectAmend
	case *Record_ObjectDeactivate:
		subRecord = *union.(*Record_ObjectDeactivate).ObjectDeactivate
	default:
		return nil, fmt.Errorf("Record.union has unexpected type %T", subRecord)
	}
	return subRecord, nil
}

// Puts sub-record into record and convert it to binary (if any)
func MarshalRecord(subRecord interface{}) ([]byte, error) {
	base := Record{}

	switch subRecord.(type) {
	case *GenesisRecord:
		base.Union = &Record_Genesis{
			subRecord.(*GenesisRecord),
		}
	case *ChildRecord:
		base.Union = &Record_Child{
			subRecord.(*ChildRecord),
		}
	case *JetRecord:
		base.Union = &Record_Jet{
			subRecord.(*JetRecord),
		}
	case *RequestRecord:
		base.Union = &Record_Request{
			subRecord.(*RequestRecord),
		}
	case *ResultRecord:
		base.Union = &Record_Result{
			subRecord.(*ResultRecord),
		}
	case *TypeRecord:
		base.Union = &Record_Type{
			subRecord.(*TypeRecord),
		}
	case *CodeRecord:
		base.Union = &Record_Code{
			subRecord.(*CodeRecord),
		}
	case *ObjectActivateRecord:
		base.Union = &Record_ObjectActivate{
			subRecord.(*ObjectActivateRecord),
		}
	case *ObjectAmendRecord:
		base.Union = &Record_ObjectAmend{
			subRecord.(*ObjectAmendRecord),
		}
	case *ObjectDeactivateRecord:
		base.Union = &Record_ObjectDeactivate{
			subRecord.(*ObjectDeactivateRecord),
		}
	default:
		return nil, fmt.Errorf("Record.union has unexpected type %T", subRecord)
	}
	return base.Marshal()
}
